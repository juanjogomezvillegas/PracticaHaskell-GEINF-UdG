\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[x11names]{xcolor}
\usepackage{fancyhdr}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\graphicspath{{./imatges/}}% Lloc on hi ha els logos

\definecolor{backcolour}{rgb}{0.83, 0.83, 0.83}
\definecolor{textcolour}{rgb}{0.0, 0.0, 0.0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    basicstyle=\ttfamily\footnotesize\color{textcolour}, 
    breakatwhitespace=false, 
    breaklines=true,  
    captionpos=b, 
    keepspaces=true,                 
    numbers=left, 
    numbersep=5pt, 
    showspaces=false, 
    showstringspaces=false, 
    showtabs=false, 
    tabsize=2
}

\lhead{Informe de la pràctica de Haskell}
\rhead{\thepage}
\cfoot{}
\begin{document}
    \begin{titlepage}
        \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
        \begin{flushleft}
            \includegraphics[height=1.5cm]{EPS.png}\\\vfill
        \end{flushleft}
        \center % Center everything on the page
        %----------------------------------------------------------------------------------------
        %	HEADING SECTIONS
        %----------------------------------------------------------------------------------------
        \textsc{\huge \bfseries Paradigmes i llenguatges de programació }\\[0.25cm]
        \textsc{\Large \bfseries Curs 2024/25}\\[0.25cm]
        \textsc{\large GEINF }
        %----------------------------------------------------------------------------------------
        %	TITLE SECTION
        %----------------------------------------------------------------------------------------
        \HRule \\[0.4cm]
        { \huge \bfseries PAC4} \\[0.4cm] % Title of your document
{Juan José Gómez Villegas, \href{mailto:u1987338@campus.udg.edu}{u1987338@campus.udg.edu}} \\ {Guillem Pozo Sebastián, \href{mailto:u1972840@campus.udg.edu}{u1972840@campus.udg.edu}}
        \HRule \\\vfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft}
		\footnotesize{Aquest document està subjecte a una llicència Creative Commons \href{https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1}{CC BY-NC-SA 4.0}.} \\\vfill
		\includegraphics[height=1.5cm]{CC_license.png}
            \end{flushleft}
        \end{minipage}
        \hfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
                {\small (\today)}
            \end{flushright}
        \end{minipage}
    \end{titlepage}

\tableofcontents

\clearpage

\section{$\lambda$-càlcul clàssic}

\subsection{Tipus}

El tipus de dades \textbf{LT} ens permet representar $\lambda$-termes, i la definició és exactament la gramàtica que diu el que és un $\lambda$-terme.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
data LT = Va String | Ap LT LT | Ab String LT

-- definim la forma de mostrar un lambda terme
instance Show LT where
    show (Va a) = a
    show (Ap t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (Ab a t1) = "(\\" ++ a ++ ". " ++ show t1 ++ ")"

-- definim la idea d'equivalencia de dos lambda termes
instance Eq LT where
    (==) (Va a) (Va b) = a == b
    (==) (Ap t1 t2) (Ap t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (Ab _ t1) (Ab _ t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

En el codi també es veu com hem fet per tal que el \textbf{tipus LT} sigui una instància de les classes \textbf{Show} i \textbf{Eq}, definint així com es mostraran els $\lambda$-termes, i que vol dir que dos $\lambda$-termes siguin equivalents. \\

També hem definit el tipus de dades \textbf{Substitució}, que ens ha permet implementar la funció substitució tal i com diu la teòria, és a dir, com un operador que ens permet reemplaçar ocurrències de variables per termes, evitant captura de variables lliures. Per tant, el tipus \textbf{Substitució} serà una variable $v$ per un terme $M'$, i la funció \textbf{subst} una \textbf{Substitució} sobre un terme $M$, tot junt representarà: $M [v -> M']$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
data Substitucio = Sub String LT
\end{lstlisting}

\subsection{Funcions auxiliars}

\subsection{Funcions principals}

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- freeAndboundVars, donat un LT retorna una tupla amb una llista de freeVars i una llista de boundVars
freeAndboundVars :: LT -> ([String],[String])
freeAndboundVars = freeAndboundVarsAux [] []

-- freeAndboundVarsAux, funcio que construeix una tupla amb dues llistes que continguin les variables lliures (first) i lligades (second)
freeAndboundVarsAux :: [String] -> [String] -> LT -> ([String],[String])
freeAndboundVarsAux freeVars boundVars (Va a) | a `elem` boundVars = (freeVars,boundVars)
                                              | otherwise = (a:freeVars,boundVars)
freeAndboundVarsAux freeVars boundVars (Ab a t1) = freeAndboundVarsAux freeVars (a:boundVars) t1
freeAndboundVarsAux freeVars boundVars (Ap t1 t2) = freeAndboundVarsAux freeVars boundVars t1 `concat_tuples` freeAndboundVarsAux freeVars boundVars t2
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- subst, donat un LT i una Substitucio, retorna el mateix LT al que se li ha aplicat la Substitucio
subst :: LT -> Substitucio -> LT
subst (Va a) (Sub v t') | a == v = t'
                        | otherwise = Va a
subst (Ap t1 t2) (Sub v t') = Ap (subst t1 (Sub v t')) (subst t2 (Sub v t'))
subst (Ab a t1) (Sub v t') | [x |x <- (fst (freeAndboundVars t')), y <- (snd (freeAndboundVars (Ab a t1))), x == y] == [] = 
                                if a == v then Ab (get_var t') (subst t1 (Sub v t')) else Ab a (subst t1 (Sub v t'))
                           | otherwise = Ab a t1
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- esta_normal, diu si LT ja esta en forma normal
esta_normal :: LT -> Bool
esta_normal = not . conte_redex
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- beta_redueix, rep un LT que sigui un redex, i el resol
beta_redueix :: LT -> LT
beta_redueix (Ap (Ab a t1) t2) = subst t1 (Sub a t2)
beta_redueix t = t
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- redueix_un_n, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre normal
redueix_un_n :: LT -> LT
redueix_un_n (Ap m n) | conte_redex (Ap m n) = beta_redueix (Ap m n)
                      | conte_redex m = Ap (redueix_un_n m) n
                      | conte_redex n = Ap m (redueix_un_n n)
                      | otherwise = Ap m n
redueix_un_n (Ab x t) = Ab x (redueix_un_n t)
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- redueix_un_a, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre aplicatiu
redueix_un_a :: LT -> LT
redueix_un_a (Ap m n) | conte_redex m = Ap (redueix_un_a m) n
                      | conte_redex n = Ap m (redueix_un_a n)
                      | conte_redex (Ap m n) = beta_redueix (Ap m n)
                      | otherwise = Ap m n
redueix_un_a (Ab x t) = Ab x (redueix_un_a t)
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- l_normalitza_n, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre normal
l_normalitza_n :: LT -> [LT]
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- l_normalitza_a, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre aplicatiu
l_normalitza_a :: LT -> [LT]
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- normalitza_n, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre normal
normalitza_n :: LT -> (Int,LT)
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- normalitza_a, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre aplicatiu
normalitza_a :: LT -> (Int,LT)
\end{lstlisting}



\section{Extra: Notació \textit{de Bruijn}}

Per \textbf{la notació de Bruijn} hem definit un altre tipus de dades, que tambe es instancia de les classes \textbf{Show} i \textbf{Eq}.

\begin{lstlisting}[language=Haskell]
data LTdB = VadB Int | ApdB LTdB LTdB | AbdB LTdB

-- que tambe sera instancia de la classe Show i Eq
instance Show LTdB where
    show (VadB a) = show a
    show (ApdB t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (AbdB t1) = "(\\" ++ ". " ++ show t1 ++ ")"

-- definim la mateixa idea d'equivalencia que teniem en els lambda termes pels lambda termes amb notacio de Bruijn
instance Eq LTdB where
    (==) (VadB a) (VadB b) = a == b
    (==) (ApdB t1 t2) (ApdB t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (AbdB t1) (AbdB t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

\end{document}
