\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[x11names]{xcolor}
\usepackage{fancyhdr}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\graphicspath{{./imatges/}}% Lloc on hi ha els logos

\definecolor{backcolour}{rgb}{0.83, 0.83, 0.83}
\definecolor{textcolour}{rgb}{0.0, 0.0, 0.0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    basicstyle=\ttfamily\footnotesize\color{textcolour}, 
    breakatwhitespace=false, 
    breaklines=true,  
    captionpos=b, 
    keepspaces=true,                 
    numbers=left, 
    numbersep=5pt, 
    showspaces=false, 
    showstringspaces=false, 
    showtabs=false, 
    tabsize=2
}

\lhead{Informe de la pràctica de Haskell}
\rhead{\thepage}
\cfoot{}
\begin{document}
    \begin{titlepage}
        \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
        \begin{flushleft}
            \includegraphics[height=1.5cm]{EPS.png}\\\vfill
        \end{flushleft}
        \center % Center everything on the page
        %----------------------------------------------------------------------------------------
        %	HEADING SECTIONS
        %----------------------------------------------------------------------------------------
        \textsc{\huge \bfseries Paradigmes i llenguatges de programació }\\[0.25cm]
        \textsc{\Large \bfseries Curs 2024/25}\\[0.25cm]
        \textsc{\large GEINF }
        %----------------------------------------------------------------------------------------
        %	TITLE SECTION
        %----------------------------------------------------------------------------------------
        \HRule \\[0.4cm]
        { \huge \bfseries Pràctica de Lambda-càlcul amb Haskell} \\[0.4cm] % Title of your document
{Juan José Gómez Villegas, \href{mailto:u1987338@campus.udg.edu}{u1987338@campus.udg.edu}} \\ {Guillem Pozo Sebastián, \href{mailto:u1972840@campus.udg.edu}{u1972840@campus.udg.edu}}
        \HRule \\\vfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft}
		\footnotesize{Aquest document està subjecte a una llicència Creative Commons \href{https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1}{CC BY-NC-SA 4.0}.} \\\vfill
		\includegraphics[height=1.5cm]{CC_license.png}
            \end{flushleft}
        \end{minipage}
        \hfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
                {\small (\today)}
            \end{flushright}
        \end{minipage}
    \end{titlepage}

\tableofcontents

\clearpage

\section{$\lambda$-càlcul clàssic}

\subsection{Tipus}

El tipus de dades \textbf{LT} ens permet representar $\lambda$-termes, i la definició és exactament la gramàtica que diu el que és un $\lambda$-terme, és a dir, un $\lambda$-terme és: una variable (Va amb un String), una aplicació (Ap seguit de dos LT) i una abstracció (Ab amb un String i seguit d'un LT), res més és un $\lambda$-terme.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]

data LT = Va String | Ap LT LT | Ab String LT

-- definim la forma de mostrar un lambda terme, els lambda termes es mostraran com (\x. (x y))
instance Show LT where
    show (Va a) = a
    show (Ap t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (Ab a t1) = "(\\" ++ a ++ ". " ++ show t1 ++ ")"

-- definim la idea d'equivalencia de dos lambda termes
instance Eq LT where
    (==) (Va a) (Va b) = a == b
    (==) (Ap t1 t2) (Ap t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (Ab _ t1) (Ab _ t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

El \textbf{tipus LT} ha de ser instància de la classe \textbf{Show}, per tal que es pugui mostrar com nosaltres volguem, \textit{com diu a l'enunciat}, i ha de ser instància de la classe \textbf{Eq}, per tal de definir la idea d'equivalència de dos $\lambda$-termes, és a dir, dos $\lambda$-termes seran el mateix quan, siguin dues abstraccions i independentment de la variable, els seus $\lambda$-termes interns siguin iguals, quan siguin dues aplicacions i aquestes siguin iguals, i quan siguin dos variables iguals llevat de $\alpha$-conversió. \\

També hem definit el tipus de dades \textbf{Substitució}, que \textbf{ens ha permès implementar la funció subst} tal com diuen les transparències de teoria (transparència 10), és a dir, \textbf{com un operador que ens permet reemplaçar ocurrències de variables per termes, evitant captura de variables lliures}. Per tant, el tipus \textbf{Substitució} serà una variable $v$ que serà reemplaçada per un terme $M'$, sobre un terme $M$, definit a la funció \textbf{subst}, tot junt representarà: $M [v \rightarrow M']$. La substitució és només el que apareix entre claus `[' i `]', com (Sub seguit d'un String ($v$) i un LT ($M'$)).

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
data Substitucio = Sub String LT
\end{lstlisting}

\subsection*{Exemples d'execució}

A partir d'aquí ja podem fer proves d'execució, p.e. com definim el $\lambda$-terme: $\lambda_x \lambda_y x y$? Doncs el definim de la manera següent:

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ab "x" (Ab "y" (Ap (Va "x") (Va "y"))))
(\x. (\y. (x y)))
\end{lstlisting}

Com comprovem que $\lambda_x x y$ és igual que $\lambda_x x z$, realment no són iguals, però podem aplicar la substitució en el segon $\lambda$-terme de la variable "z" per la variable "y".

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ab "x" (Ap (Va "x") (Va "y"))) == (Ab "x" (Ap (Va "x") (Va "z")))
False
*Main> (Ab "x" (Ap (Va "x") (Va "y"))) == (subst (Ab "x" (Ap (Va "x") (Va "z"))) (Sub "z" (Va "y")))
True
\end{lstlisting}

\clearpage

\subsection{Funcions auxiliars}

Les següents funcions ens permeten implementar les funcions principals de forma més fàcil i fins i tot com funcions d'ordre superior. \\

La funció \textbf{es\_redex} ens diu si un $\lambda$-terme té la forma d'un redex, o no. p.e. donat un terme $(\lambda_x \lambda_y x) a b$, això és un redex, i també ho és $(\lambda_x \lambda_y x) (a b)$, però $\lambda_x x$ no és un redex, tot i que $(\lambda_x x) a$ sí que ho és. Aquesta estructura del que és un redex és el patró que fa que la funció retorni cert, si el terme no segueix aquest patró retorna fals, és a dir, la funció només comprovar que el terme inicial té l'estructura d'un redex, sense entrar-hi a dins.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- es_redex, funcio que donat un LT, retorna True si es un redex, False altrament
es_redex :: LT -> Bool
es_redex (Ap (Ab _ _) _) = True
es_redex _ = False
\end{lstlisting}

Els exemples els farem amb el terme $\lambda_x x$, que l'hem definit en el codi com \textbf{iden}, és a dir, \textbf{identitat}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> iden
(\x. x)
*Main> es_redex iden
False
*Main> es_redex (Ap iden (Va "a"))
True
\end{lstlisting}

Aquesta funció és molt útil, però encara més la següent que a partir d'aquesta funció (es\_redex), comprova si un terme conté un redex a dins, aquesta funció es diu \textbf{conte\_redex}, i aquesta sí que entra a dins del terme per comprovar, fent servir la funció es\_redex, si conté un redex, i funciona de la manera següent: Una variable no conté cap redex (retorna fals, cas base), una abstracció conté un redex, si i només si, el terme que conté a dins \textbf{és un redex}, o si no, si conté un redex més a dins, i una aplicació conté un redex, si qualsevol dels dos termes de dins \textbf{són o contenen un redex} més a dins. Amb aquesta funció hem pogut simplificar el codi de les funcions principals.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- conte_redex, funcio que determina si un terme conte qualsevol redex (en qualsevol nivell, equivalent a fer esRedex sobre tot el terme)
conte_redex :: LT -> Bool
conte_redex (Va _) = False
conte_redex (Ab _ t) | es_redex t = True
                     | otherwise = conte_redex t
conte_redex (Ap t1 t2) | es_redex (Ap t1 t2) = True
                       | es_redex t1 = True
                       | es_redex t2 = True
                       | otherwise = conte_redex t1 || conte_redex t2
\end{lstlisting}

I continuant amb el terme \textbf{identitat}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> conte_redex (Ap iden (Va "a"))
True
*Main> conte_redex iden
False 
\end{lstlisting}

\clearpage

La següent funció és una funció auxiliar que donades dues llistes de cadenes de caràcters i un $\lambda$-terme, retorna una tupla amb dues llistes de cadenes de caràcters, la funció és diu \textbf{freeAndboundVarsAux}, i amb el nom ja es pot saber el que retornarà, és a dir, \textbf{retornarà una tupla}, on \textbf{la primera llista són les variables lliures} del terme, i \textbf{la segona llista són les variables lligades}. Dir que l'ordre en que s'han definit els paràmetres és molt important, perquè això ens permetra definir la funció principal \textbf{freeAndboundVars} com una funció d'ordre superior.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- freeAndboundVarsAux, funcio que construeix una tupla amb dues llistes que continguin les variables lliures (first) i lligades (second)
freeAndboundVarsAux :: [String] -> [String] -> LT -> ([String],[String])
freeAndboundVarsAux freeVars boundVars (Va a) | a `elem` boundVars = (freeVars,boundVars)
                                              | otherwise = (a:freeVars,boundVars)
freeAndboundVarsAux freeVars boundVars (Ab a t1) = freeAndboundVarsAux freeVars (a:boundVars) t1
freeAndboundVarsAux freeVars boundVars (Ap t1 t2) = freeAndboundVarsAux freeVars boundVars t1 `concat_tuples` freeAndboundVarsAux freeVars boundVars t2
\end{lstlisting}

Pels exemples d'execució podem fer servir la identitat, o el combinador $G = (\lambda_x ((\lambda_y (\lambda_x  y y)) (\lambda_y (\lambda_x  y y))))$, també definit en el codi.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> freeAndboundVarsAux [] [] iden
([],["x"])
*Main> freeAndboundVarsAux [] [] g
([],["y","x"])
\end{lstlisting}

De forma més senzilla també podem fer servir la funció \textbf{freeAndboundVars}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> freeAndboundVars iden
([],["x"])
*Main> freeAndboundVars g
([],["y","x"])
\end{lstlisting}

Les següents funcions són sobre llistes, algunes s'ha fet servir la funció \textbf{foldr} perquè era igual començar pel primer o per l'últim element. En el cas de \textbf{eliminar\_duplicats}, l'element neutre (cas base) és la llista buida, en una llista buida segur que no hi han repetits, perquè està buida, i el cas recursiu fent servir les lambdes és si el primer element pertany a la resta, retorna la cua, altrament retorna el primer element seguit de la cua. En el cas de \textbf{llargada}, l'element neutre és 0 i va sumant 1 per cada element de la llista. I en el cas de \textbf{concat\_tuples}, donades dues tuples, p.e. $(a,b)$ i $(c,d)$, concatenarà el primer element de la primera tupla amb el primer de la segona, i el segon element de la primera amb el segon element de la segona, és a dir, retornarà $(a+c.b+d)$, aquesta és útil per la funció auxiliar vista anteriorment, en el cas de l'aplicació.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- eliminar_duplicats, funcio que elimina els elements duplicats d'una llista
eliminar_duplicats :: Eq a => [a] -> [a]
eliminar_duplicats = foldr (\x xs -> if x `elem` xs then xs else x:xs) []

-- concat_tuples, operador que concatena o intercalar dues llistes que son a dins d'una tupla
concat_tuples :: Eq a => ([a],[a]) -> ([a],[a]) -> ([a],[a])
concat_tuples t1 t2 = (eliminar_duplicats (fst t1 ++ fst t2),eliminar_duplicats (snd t1 ++ snd t2))

-- llargada, funcio que retorna la llargada d'una llista
llargada :: [a] -> Int
llargada = foldr (\_ y -> 1+y) 0
\end{lstlisting}

Exemples d'execució:

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> concat_tuples ("a","b") ("c","d")
("ac","bd")
*Main> eliminar_duplicats ["a","a","a","b","c","c"]
["a","b","c"]
*Main> llargada (l_normalitza_n (Ap iden (Va "a")))
2
\end{lstlisting}

Cadascuna d'aquestes funcions soluciona problemes trobats en la implementació de les funcions principals, concat\_tuples a la funció freeAndboundVars, eliminar\_duplicats soluciona un problema a la mateixa funció (freeAndboundVars), on les variables lliures o lligades sortien repetides, i tal com es veu, la funció llargada es fa servir a la funció normalitza\_n i normalitza\_a.

\clearpage

\subsection{Funcions principals}

La funció \textbf{freeAndboundVars}, crida a la funció \textbf{freeAndboundVarsAux} com una funció d'ordre superior, inicialitzant dues llistes buides (una per variables lliures i l'altre per variables lligades), i fa servir la funció \textbf{freeAndboundVarsAux}, explicada anteriorment.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- freeAndboundVars, donat un LT retorna una tupla amb una llista de freeVars i una llista de boundVars
freeAndboundVars :: LT -> ([String],[String])
freeAndboundVars = freeAndboundVarsAux [] []
\end{lstlisting}

Potser la funció més interessant sigui la funció \textbf{subst}, que donat un terme i una substitució retorna un terme al qual se li ha aplicat la substitució, és a dir, és la implementació en codi Haskell del que a teoria era $M [v \rightarrow M']$, i el codi està basat en la transparència 10 de les transparències de teoria. Si és una variable, fem la substitució si la forma de $M$ és $v$, si és una aplicació, fem la substitució per separat, si és una abstracció: sí la forma de $M$ és $\lambda_v M_1$ llavors no fem res, però si és $\lambda_a M_1$ per $a \neq v$, aquí és on hem de tenir precaució de no capturar cap variable lliure, llavors sí la variable de la lambda no pertany a les variables lliures de $M'$, fem la substitució, altrament si pertany a les variables lliures de $M'$, hem de fer la $\alpha$-conversió abans de fer la substitució que volem fer, i la $\alpha$-conversió l'hem definit com, anem afegint primes a la variable de la lambda fins que aquesta estigui lliure a $M'$ i a $M$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- subst, donat un LT i una Substitucio, retorna el mateix LT al que se li ha aplicat la Substitucio
subst :: LT -> Substitucio -> LT
subst (Va a) (Sub v t') | a == v = t'
                        | otherwise = Va a
subst (Ap t1 t2) (Sub v t') = Ap (subst t1 (Sub v t')) (subst t2 (Sub v t'))
subst (Ab a t1) (Sub v t') | a == v = Ab a t1
                           | a /= v && a `notElem` fst (freeAndboundVars t') = Ab a (subst t1 (Sub v t'))
                           | a /= v && a `elem` fst (freeAndboundVars t') = subst (alfa_conv t1 t' a (a ++ "\'")) (Sub v t')
                           | otherwise = Ab a t1
    where alfa_conv t1 t' v' v'' | v'' `notElem` fst (freeAndboundVars t') && v'' `notElem` fst (freeAndboundVars t1) = Ab v'' (subst t1 (Sub v' (Va v'')))
                                 | otherwise = alfa_conv t1 t' v' (v'' ++ "\'")
\end{lstlisting}

Exemples d'execució, donat el terme $(\lambda_x x y) [y \rightarrow z] = \lambda_x x z)$, però $(\lambda_x x y) [x \rightarrow y] = \lambda_x x y)$, la substitució només substitueix variables lliures, per això en la segona substitució queda igual. Un altre exemple és $(\lambda_x x y) [y \rightarrow x] = \lambda_{x'} {x'} x)$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "y" (Va "z"))
(\x. (x z))
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "x" (Va "y"))
(\x. (x y))
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "y" (Va "x"))
(\x'. (x' x))
\end{lstlisting}

A partir d'aquí, la següent funció és \textbf{esta\_normal}, el que ens diu és si un $\lambda$-terme qualsevol està en forma normal, és a dir, que no conté cap redex. Per tant, la podem definir com la composició de la funció not amb conte\_redex, com que es llegeix de dreta a esquerra primer avaluaria la funció conte\_redex, que si està en forma normal retornarà fals, i després el not retornarà cert.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- esta_normal, diu si LT ja esta en forma normal
esta_normal :: LT -> Bool
esta_normal = not . conte_redex
\end{lstlisting}

Exemples d'execució són els següents, amb les definicions de la identitat i del combinador G.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> esta_normal iden
True
*Main> esta_normal g
False
\end{lstlisting}

\clearpage

La funció \textbf{beta\_redueix}, igual que es\_redex, busca que el terme tingui la forma d'un redex, per fer la substitució com $t1 [a \rightarrow t2]$, si el terme comença amb una abstracció crida a la mateixa funció beta\_redueix amb el terme $t$ de dins seu, i finalment, per qualsevol altre terme retorna el mateix terme.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- beta_redueix, rep un LT que sigui un redex, i el resol
beta_redueix :: LT -> LT
beta_redueix (Ap (Ab a t1) t2) = subst t1 (Sub a t2)
beta_redueix (Ab _ t) = beta_redueix t
beta_redueix t = t
\end{lstlisting}

Exemples d'execució són els següents, amb la definició del combinador $Y$, com $Y F$, que com es un combinador de punt fixe el resultat serà $F (Y F)$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ap y (Va "F"))
((\f. ((\x. (f (x x))) (\x. (f (x x))))) F)
*Main> beta_redueix (Ap y (Va "F"))
((\x. (F (x x))) (\x. (F (x x))))
*Main> beta_redueix (Ap (Ab "x" (Ap (Va "F") (Ap (Va "x") (Va "x")))) (Ab "x" (Ap (Va "F") (Ap (Va "x") (Va "x")))))
(F ((\x. (F (x x))) (\x. (F (x x)))))
\end{lstlisting}

Per tant, podem simular la recursivitat.

\clearpage

Les següents funcions són simètriques, són les funcions redueix\_un\_n, l\_normalitza\_n i normalitza\_n (ordre normal) i redueix\_un\_a, l\_normalitza\_a i normalitza\_a (ordre aplicatiu).

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- redueix_un_n, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre normal
redueix_un_n :: LT -> LT
redueix_un_n (Ap m n) | es_redex (Ap m n) = beta_redueix (Ap m n)
                      | conte_redex m = Ap (redueix_un_n m) n
                      | conte_redex n = Ap m (redueix_un_n n)
                      | otherwise = Ap m n
redueix_un_n (Ab x t) = Ab x (redueix_un_n t)
\end{lstlisting}

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- redueix_un_a, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre aplicatiu
redueix_un_a :: LT -> LT
redueix_un_a (Ap m n) | conte_redex m = Ap (redueix_un_a m) n
                      | conte_redex n = Ap m (redueix_un_a n)
                      | es_redex (Ap m n) = beta_redueix (Ap m n)
                      | otherwise = Ap m n
redueix_un_a (Ab x t) = Ab x (redueix_un_a t)
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- l_normalitza_n, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre normal
l_normalitza_n :: LT -> [LT]
l_normalitza_n t | esta_normal t = t:[]
                 | otherwise = t:l_normalitza_n t'
    where t' = redueix_un_n t
\end{lstlisting}

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- l_normalitza_a, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre aplicatiu
l_normalitza_a :: LT -> [LT]
l_normalitza_a t | esta_normal t = t:[]
                 | otherwise = t:l_normalitza_a t'
    where t' = redueix_un_a t
\end{lstlisting}



\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- normalitza_n, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre normal
normalitza_n :: LT -> (Int, LT)
normalitza_n t = (llargada (lpassos t),last (lpassos t))
    where lpassos = l_normalitza_n
\end{lstlisting}

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- normalitza_a, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre aplicatiu
normalitza_a :: LT -> (Int, LT)
normalitza_a t = (llargada (lpassos t),last (lpassos t))
    where lpassos = l_normalitza_a
\end{lstlisting}

\clearpage

\section{Extra: Notació \textit{de Bruijn}}

\subsection{Tipus}

Per \textbf{la notació de Bruijn} hem definit un altre tipus de dades, que també és instància de les classes \textbf{Show} i \textbf{Eq}, igual que abans, l'únic que canvia en aquest tipus, és que ja no tenim variables en les $\lambda$-abstraccions, i les variables que abans eren cadenes de text, ara són enters, més concretament és la distància de cada variable en lambdes.

\begin{lstlisting}[language=Haskell]
data LTdB = VadB Int | ApdB LTdB LTdB | AbdB LTdB

-- que tambe sera instancia de la classe Show i Eq
instance Show LTdB where
    show (VadB a) = show a
    show (ApdB t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (AbdB t1) = "(\\" ++ ". " ++ show t1 ++ ")"

-- definim la mateixa idea d'equivalencia que teniem en els lambda termes pels lambda termes amb notacio de Bruijn
instance Eq LTdB where
    (==) (VadB a) (VadB b) = a == b
    (==) (ApdB t1 t2) (ApdB t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (AbdB t1) (AbdB t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

També hem hagut de definir un Context.

\begin{lstlisting}[language=Haskell]
type Context = String
\end{lstlisting}

\clearpage

\subsection{Funcions auxiliars}

\clearpage

\subsection{Funcions principals}

\end{document}
