\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[x11names]{xcolor}
\usepackage{fancyhdr}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\graphicspath{{./imatges/}}% Lloc on hi ha els logos

\definecolor{backcolour}{rgb}{0.83, 0.83, 0.83}
\definecolor{textcolour}{rgb}{0.0, 0.0, 0.0}
\definecolor{keywordcolour}{rgb}{0.0, 0.0, 1.0}
\definecolor{commentcolour}{rgb}{0.0, 0.5, 0.0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    basicstyle=\ttfamily\footnotesize\color{textcolour}, 
    keywordstyle=\color{keywordcolour}, 
    commentstyle=\color{commentcolour}, 
    breakatwhitespace=false, 
    breaklines=true,  
    captionpos=b, 
    keepspaces=true,                 
    numbers=left, 
    numbersep=5pt, 
    showspaces=false, 
    showstringspaces=false, 
    showtabs=false, 
    tabsize=2
}

\lhead{Informe de la pràctica de Haskell}
\rhead{\thepage}
\cfoot{}
\begin{document}
    \begin{titlepage}
        \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
        \begin{flushleft}
            \includegraphics[height=1.5cm]{EPS.png}\\\vfill
        \end{flushleft}
        \center % Center everything on the page
        %----------------------------------------------------------------------------------------
        %	HEADING SECTIONS
        %----------------------------------------------------------------------------------------
        \textsc{\huge \bfseries Paradigmes i llenguatges de programació }\\[0.25cm]
        \textsc{\Large \bfseries Curs 2024/25}\\[0.25cm]
        \textsc{\large GEINF }
        %----------------------------------------------------------------------------------------
        %	TITLE SECTION
        %----------------------------------------------------------------------------------------
        \HRule \\[0.4cm]
        { \huge \bfseries Pràctica de Lambda-càlcul amb Haskell} \\[0.4cm] % Title of your document
{Juan José Gómez Villegas, \href{mailto:u1987338@campus.udg.edu}{u1987338@campus.udg.edu}} \\ {Guillem Pozo Sebastián, \href{mailto:u1972840@campus.udg.edu}{u1972840@campus.udg.edu}}
        \HRule \\\vfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft}
		\footnotesize{Aquest document està subjecte a una llicència Creative Commons \href{https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1}{CC BY-NC-SA 4.0}.} \\\vfill
		\includegraphics[height=1.5cm]{CC_license.png}
            \end{flushleft}
        \end{minipage}
        \hfill
        \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
                {\small (\today)}
            \end{flushright}
        \end{minipage}
    \end{titlepage}

\tableofcontents

\clearpage

\section{$\lambda$-càlcul clàssic}

\subsection{Tipus}

El tipus de dades \textbf{LT} ens permet representar $\lambda$-termes, i la definició és exactament la gramàtica que diu el que és un $\lambda$-terme, és a dir, un $\lambda$-terme és: una variable (Va amb un String), una aplicació (Ap seguit de dos LT) i una abstracció (Ab amb un String i seguit d'un LT), res més és un $\lambda$-terme.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]

data LT = Va String | Ap LT LT | Ab String LT

-- definim la forma de mostrar un lambda terme, els lambda termes es mostraran com (\x. (x y))
instance Show LT where
    show (Va a) = a
    show (Ap t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (Ab a t1) = "(\\" ++ a ++ ". " ++ show t1 ++ ")"

-- definim la idea d'equivalencia de dos lambda termes
instance Eq LT where
    (==) (Va a) (Va b) = a == b
    (==) (Ap t1 t2) (Ap t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (Ab _ t1) (Ab _ t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

El \textbf{tipus LT} ha de ser instància de la classe \textbf{Show}, per tal que es pugui mostrar com nosaltres volguem, \textit{com diu a l'enunciat}, i ha de ser instància de la classe \textbf{Eq}, per tal de definir la idea d'equivalència de dos $\lambda$-termes, és a dir, dos $\lambda$-termes seran el mateix quan, siguin dues abstraccions i independentment de la variable, els seus $\lambda$-termes interns siguin iguals, quan siguin dues aplicacions i aquestes siguin iguals, i quan siguin dos variables iguals llevat de $\alpha$-conversió. \\

També hem definit el tipus de dades \textbf{Substitució}, que \textbf{ens ha permès implementar la funció subst} tal com diuen les transparències de teoria (transparència 10), és a dir, \textbf{com un operador que ens permet reemplaçar ocurrències de variables per termes, evitant captura de variables lliures}. Per tant, el tipus \textbf{Substitució} serà una variable $v$ que serà reemplaçada per un terme $M'$, sobre un terme $M$, definit a la funció \textbf{subst}, tot junt representarà: $M [v \rightarrow M']$. La substitució és només el que apareix entre claus `[' i `]', com (Sub seguit d'un String ($v$) i un LT ($M'$)).

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
data Substitucio = Sub String LT
\end{lstlisting}

\subsection*{Exemples d'execució}

A partir d'aquí ja podem fer proves d'execució, p.e. com definim el $\lambda$-terme: $\lambda_x \lambda_y x y$? Doncs el definim de la manera següent:

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ab "x" (Ab "y" (Ap (Va "x") (Va "y"))))
(\x. (\y. (x y)))
\end{lstlisting}

Com comprovem que $\lambda_x x y$ és igual que $\lambda_x x z$, realment no són iguals, però podem aplicar la substitució en el segon $\lambda$-terme de la variable "z" per la variable "y".

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ab "x" (Ap (Va "x") (Va "y"))) == (Ab "x" (Ap (Va "x") (Va "z")))
False
*Main> (Ab "x" (Ap (Va "x") (Va "y"))) == (subst (Ab "x" (Ap (Va "x") (Va "z"))) (Sub "z" (Va "y")))
True
\end{lstlisting}

\clearpage

\subsection{Funcions auxiliars}

Les següents funcions ens permeten implementar les funcions principals de forma més fàcil i fins i tot com funcions d'ordre superior. \\

La funció \textbf{es\_redex} ens diu si un $\lambda$-terme té la forma d'un redex, o no. p.e. donat un terme $(\lambda_x \lambda_y x) a b$, això és un redex, i també ho és $(\lambda_x \lambda_y x) (a b)$, però $\lambda_x x$ no és un redex, tot i que $(\lambda_x x) a$ sí que ho és. Aquesta estructura del que és un redex és el patró que fa que la funció retorni cert, si el terme no segueix aquest patró retorna fals, és a dir, la funció només comprovar que el terme inicial té l'estructura d'un redex, sense entrar-hi a dins.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- es_redex, funcio que donat un LT, retorna True si es un redex, False altrament
es_redex :: LT -> Bool
es_redex (Ap (Ab _ _) _) = True
es_redex _ = False
\end{lstlisting}

Els exemples els farem amb el terme $\lambda_x x$, que l'hem definit en el codi com \textbf{iden}, és a dir, \textbf{identitat}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> iden
(\x. x)
*Main> es_redex iden
False
*Main> es_redex (Ap iden (Va "a"))
True
\end{lstlisting}

Aquesta funció és molt útil, però encara més la següent que a partir d'aquesta funció (es\_redex), comprova si un terme conté un redex a dins, aquesta funció es diu \textbf{conte\_redex}, i aquesta sí que entra a dins del terme per comprovar, fent servir la funció es\_redex, si conté un redex, i funciona de la manera següent: Una variable no conté cap redex (retorna fals, cas base), una abstracció conté un redex, si i només si, el terme que conté a dins \textbf{és un redex}, o si no, si conté un redex més a dins, i una aplicació conté un redex, si qualsevol dels dos termes de dins \textbf{són o contenen un redex} més a dins. Amb aquesta funció hem pogut simplificar el codi de les funcions principals.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- conte_redex, funcio que determina si un terme conte qualsevol redex (en qualsevol nivell, equivalent a fer esRedex sobre tot el terme)
conte_redex :: LT -> Bool
conte_redex (Va _) = False
conte_redex (Ab _ t) | es_redex t = True
                     | otherwise = conte_redex t
conte_redex (Ap t1 t2) | es_redex (Ap t1 t2) = True
                       | es_redex t1 = True
                       | es_redex t2 = True
                       | otherwise = conte_redex t1 || conte_redex t2
\end{lstlisting}

I continuant amb el terme \textbf{identitat}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> conte_redex (Ap iden (Va "a"))
True
*Main> conte_redex iden
False 
\end{lstlisting}

La següent funció és una funció auxiliar que donades dues llistes de cadenes de caràcters i un $\lambda$-terme, retorna una tupla amb dues llistes de cadenes de caràcters, la funció és diu \textbf{freeAndboundVarsAux}, i amb el nom ja es pot saber el que retornarà, és a dir, \textbf{retornarà una tupla}, on \textbf{la primera llista són les variables lliures} del terme, i \textbf{la segona llista són les variables lligades}. Dir que l'ordre en que s'han definit els paràmetres és molt important, perquè això ens permetra definir la funció principal \textbf{freeAndboundVars} de forma més senzilla.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- freeAndboundVarsAux, funcio que construeix una tupla amb dues llistes que continguin les variables lliures (first) i lligades (second)
freeAndboundVarsAux :: [String] -> [String] -> LT -> ([String],[String])
freeAndboundVarsAux freeVars boundVars (Va a) | a `elem` boundVars = (freeVars,boundVars)
                                              | otherwise = (freeVars ++ [a],boundVars)
freeAndboundVarsAux freeVars boundVars (Ab a t1) = freeAndboundVarsAux freeVars (boundVars ++ [a]) t1
freeAndboundVarsAux freeVars boundVars (Ap t1 t2) = freeAndboundVarsAux freeVars boundVars t1 `concat_tuples` freeAndboundVarsAux freeVars boundVars t2
\end{lstlisting}

\clearpage

Pels exemples d'execució podem fer servir la identitat, o el combinador $G = (\lambda_x ((\lambda_y (\lambda_x  y y)) (\lambda_y (\lambda_x  y y))))$, també definit en el codi.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> freeAndboundVarsAux [] [] iden
([],["x"])
*Main> freeAndboundVarsAux [] [] g
([],["y","x"])
\end{lstlisting}

De forma més senzilla també podem fer servir la funció \textbf{freeAndboundVars}.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> freeAndboundVars iden
([],["x"])
*Main> freeAndboundVars g
([],["y","x"])
\end{lstlisting}

Les següents funcions són sobre llistes, algunes s'ha fet servir la funció \textbf{foldr} perquè era igual començar pel primer o per l'últim element. En el cas de \textbf{eliminar\_duplicats}, l'element neutre (cas base) és la llista buida, en una llista buida segur que no hi han repetits, perquè està buida, i el cas recursiu fent servir les lambdes és si el primer element pertany a la resta, retorna la cua, altrament retorna el primer element seguit de la cua. En el cas de \textbf{llargada}, l'element neutre és 0 i va sumant 1 per cada element de la llista. I en el cas de \textbf{concat\_tuples}, donades dues tuples, p.e. $(a,b)$ i $(c,d)$, concatenarà el primer element de la primera tupla amb el primer de la segona, i el segon element de la primera amb el segon element de la segona, és a dir, retornarà $(a+c.b+d)$, aquesta és útil per la funció auxiliar vista anteriorment, en el cas de l'aplicació.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- eliminar_duplicats, funcio que elimina els elements duplicats d'una llista
eliminar_duplicats :: Eq a => [a] -> [a]
eliminar_duplicats = foldr (\x xs -> if x `elem` xs then xs else x:xs) []

-- concat_tuples, operador que concatena o intercalar dues llistes que son a dins d'una tupla
concat_tuples :: Eq a => ([a],[a]) -> ([a],[a]) -> ([a],[a])
concat_tuples t1 t2 = (eliminar_duplicats (fst t1 ++ fst t2),eliminar_duplicats (snd t1 ++ snd t2))

-- llargada, funcio que retorna la llargada d'una llista
llargada :: [a] -> Int
llargada = foldr (\_ y -> 1+y) 0
\end{lstlisting}

Exemples d'execució:

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> concat_tuples ("a","b") ("c","d")
("ac","bd")
*Main> eliminar_duplicats ["a","a","a","b","c","c"]
["a","b","c"]
*Main> llargada (l_normalitza_n (Ap iden (Va "a")))
2
\end{lstlisting}

Cadascuna d'aquestes funcions soluciona problemes trobats en la implementació de les funcions principals, concat\_tuples a la funció freeAndboundVarsAux, eliminar\_duplicats soluciona un problema a la mateixa funció (freeAndboundVarsAux), on les variables lliures o lligades sortien repetides, i tal com es veu, la funció llargada es fa servir a la funció normalitza.

\clearpage

\subsection{Funcions principals}

La funció \textbf{freeAndboundVars}, crida a la funció \textbf{freeAndboundVarsAux} inicialitzant dues llistes buides, i el terme $t$ no cal afegir-ho, ja que com hauria d'aparèixer al final de tot, Haskell ja entén que al final ha d'afegir un LT.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- freeAndboundVars, donat un LT retorna una tupla amb una llista de freeVars i una llista de boundVars
freeAndboundVars :: LT -> ([String],[String])
freeAndboundVars = freeAndboundVarsAux [] []
\end{lstlisting}

Potser la funció més interessant sigui la funció \textbf{subst}, que donat un terme i una substitució retorna un terme al qual se li ha aplicat la substitució, és a dir, és la implementació en codi Haskell del que a teoria era $M [v \rightarrow M']$, i el codi està basat en la transparència 10 de les transparències de teoria. Si és una variable, fem la substitució si la forma de $M$ és $v$, si és una aplicació, fem la substitució per separat, si és una abstracció: sí la forma de $M$ és $\lambda_v M_1$ llavors no fem res, però si és $\lambda_a M_1$ per $a \neq v$, aquí és on hem de tenir precaució de no capturar cap variable lliure, llavors sí la variable de la lambda no pertany a les variables lliures de $M'$, fem la substitució, altrament si pertany a les variables lliures de $M'$, hem de fer la $\alpha$-conversió abans de fer la substitució que volem fer, i la $\alpha$-conversió l'hem definit com, anem afegint primes a la variable de la lambda fins que aquesta estigui lliure a $M'$ i a $M$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- subst, donat un LT i una Substitucio, retorna el mateix LT al que se li ha aplicat la Substitucio
subst :: LT -> Substitucio -> LT
subst (Va a) (Sub v t') | a == v = t'
                        | otherwise = Va a
subst (Ap t1 t2) (Sub v t') = Ap (subst t1 (Sub v t')) (subst t2 (Sub v t'))
subst (Ab a t1) (Sub v t') | a == v = Ab a t1
                           | a /= v && a `notElem` fst (freeAndboundVars t') = Ab a (subst t1 (Sub v t'))
                           | a /= v && a `elem` fst (freeAndboundVars t') = subst (alfa_conv t1 t' a (a ++ "\'")) (Sub v t')
                           | otherwise = Ab a t1
    where alfa_conv t1 t' v' v'' | v'' `notElem` fst (freeAndboundVars t') && v'' `notElem` fst (freeAndboundVars t1) = Ab v'' (subst t1 (Sub v' (Va v'')))
                                 | otherwise = alfa_conv t1 t' v' (v'' ++ "\'")
\end{lstlisting}

Exemples d'execució, donat el terme $(\lambda_x x y) [y \rightarrow z] = \lambda_x x z)$, però $(\lambda_x x y) [x \rightarrow y] = \lambda_x x y)$, la substitució només substitueix variables lliures, per això en la segona substitució queda igual. Un altre exemple és $(\lambda_x x y) [y \rightarrow x] = \lambda_{x'} {x'} x)$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "y" (Va "z"))
(\x. (x z))
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "x" (Va "y"))
(\x. (x y))
*Main> subst (Ab "x" (Ap (Va "x") (Va "y"))) (Sub "y" (Va "x"))
(\x'. (x' x))
\end{lstlisting}

A partir d'aquí, la següent funció és \textbf{esta\_normal}, el que ens diu és si un $\lambda$-terme qualsevol està en forma normal, és a dir, que no conté cap redex. Per tant, la podem definir com la composició de la funció not amb conte\_redex, com que es llegeix de dreta a esquerra primer avaluaria la funció conte\_redex, que si està en forma normal retornarà fals, i després el not retornarà cert.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- esta_normal, diu si LT ja esta en forma normal
esta_normal :: LT -> Bool
esta_normal = not . conte_redex
\end{lstlisting}

Exemples d'execució són els següents, amb les definicions de la identitat i del combinador G.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> esta_normal iden
True
*Main> esta_normal g
False
\end{lstlisting}

\clearpage

La funció \textbf{beta\_redueix}, igual que es\_redex, busca que el terme tingui la forma d'un redex, per fer la substitució com $t1 [a \rightarrow t2]$, si el terme comença amb una abstracció crida a la mateixa funció beta\_redueix amb el terme $t$ de dins seu, i finalment, per qualsevol altre terme retorna el mateix terme.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- beta_redueix, rep un LT que sigui un redex, i el resol
beta_redueix :: LT -> LT
beta_redueix (Ap (Ab a t1) t2) = subst t1 (Sub a t2)
beta_redueix (Ab _ t) = beta_redueix t
beta_redueix t = t
\end{lstlisting}

Exemples d'execució són els següents, amb la definició del combinador $Y$, com $Y F$, que com es un combinador de punt fixe el resultat serà $F (Y F)$.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> (Ap y (Va "F"))
((\f. ((\x. (f (x x))) (\x. (f (x x))))) F)
*Main> beta_redueix (Ap y (Va "F"))
((\x. (F (x x))) (\x. (F (x x))))
*Main> beta_redueix (Ap (Ab "x" (Ap (Va "F") (Ap (Va "x") (Va "x")))) (Ab "x" (Ap (Va "F") (Ap (Va "x") (Va "x")))))
(F ((\x. (F (x x))) (\x. (F (x x)))))
\end{lstlisting}

Per tant, \textbf{podem simular la recursivitat}. \\

Les següents funcions són simètriques, són les funcions redueix\_un\_n, l\_normalitza\_n i normalitza\_n (ordre normal) i redueix\_un\_a, l\_normalitza\_a i normalitza\_a (ordre aplicatiu), per això, i per cada una d'elles hem definit funcions d'ordre superior com: redueix\_un, l\_normalitza i normalitza. \\

La funció redueix\_un (d'ordre superior), i redueix\_un\_n i redueix\_un\_a, aquí el codi era igual, l'única cosa que canviava era el cas base, i només canviava l'ordre de les guardes, per tant, la funció redueix\_un espera dos paràmetres, el cas base i un terme, si el terme és una aplicació crida al cas base amb el terme com a primer paràmetre, i si és una abstracció crida a la mateixa funció amb els mateixos paràmetres. Des de redueix\_un\_n i redueix\_un\_a només li passem el terme, i depèn de quina funció fem servir, en el cas base les guardes tindran un ordre o un altre.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- redueix_un, funcio d'ordre superior que evita la repeticio de codi entra la forma normal i l'aplicatiu
redueix_un :: (LT -> LT) -> LT -> LT
redueix_un f (Ap m n) = f (Ap m n)
redueix_un f (Ab x t) = Ab x (redueix_un f t)

-- redueix_un_n, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre normal
redueix_un_n :: LT -> LT
redueix_un_n = redueix_un casbase
    where casbase (Ap m n) | es_redex (Ap m n) = beta_redueix (Ap m n)
                           | not (esta_normal m) = Ap (redueix_un casbase m) n
                           | not (esta_normal n) = Ap m (redueix_un casbase n)
                           | otherwise = Ap m n

-- redueix_un_a, rep un LT, i retorna el LT resultant d'aplicar la primera beta-reduccio segons l'ordre aplicatiu
redueix_un_a :: LT -> LT
redueix_un_a = redueix_un casbase
    where casbase (Ap m n) | not (esta_normal m) = Ap (redueix_un casbase m) n
                           | not (esta_normal n) = Ap m (redueix_un casbase n)
                           | es_redex (Ap m n) = beta_redueix (Ap m n)
                           | otherwise = Ap m n
\end{lstlisting}

Exemples, podem provar de reduir el redex, $((\lambda_x \lambda_y x) a)$, primer en ordre normal (redueix\_un\_n), i després en ordre aplicatiu (redueix\_un\_a).

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> redueix_un_n (Ap true (Va "a"))
(\y. a)
*Main> redueix_un_a (Ap true (Va "a"))
(\y. a)
\end{lstlisting}

\clearpage

Amb les funcions l\_normalitza (d'ordre superior), l\_normalitza\_n, l\_normalitza\_a, donat un terme, obtenim la llista de $\beta$-reduccions que cal fer per obtenir la forma normal, l'última posició és la forma normal. Aquest codi està a la funció d'ordre superior (l\_normalitza), i des de l\_normalitza\_n, l\_normalitza\_a només es fa la crida a aquesta funció d'ordre superior, passant per paràmetre la funció redueix\_un\_n o a, i el terme implícit com a segon paràmetre.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- l_normalitza, funcio d'ordre superior que evita la repeticio de codi entra la forma normal i l'aplicatiu
l_normalitza :: (LT -> LT) -> LT -> [LT]
l_normalitza f t | esta_normal t = t:[]
                 | otherwise = t:l_normalitza f t'
    where t' = f t

-- l_normalitza_n, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre normal
l_normalitza_n :: LT -> [LT]
l_normalitza_n = l_normalitza (redueix_un_n)

-- l_normalitza_a, rep un LT, i retorna una llista de LT's que sigui una sequencia de beta-reduccions, segons l'ordre aplicatiu
l_normalitza_a :: LT -> [LT]
l_normalitza_a = l_normalitza (redueix_un_a)
\end{lstlisting}

Exemples, continuem amb el terme, $((\lambda_x \lambda_y x) a)$, primer en ordre normal, i després en ordre aplicatiu.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> l_normalitza_n (Ap true (Va "a"))
[((\x. (\y. x)) a),(\y. a)]
*Main> l_normalitza_a (Ap true (Va "a"))
[((\x. (\y. x)) a),(\y. a)]
\end{lstlisting}

Com que només hi ha un redex, l'ordre normal o aplicatiu és el mateix, però si provem amb el terme, $(\lambda_x x ((\lambda_y y) b)) a$, conté dos redex l'ordre normal i aplicatiu no seran el mateix.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> l_normalitza_n (Ap (Ab "x" (Ap (Va "x") (Ap (Ab "y" (Va "y")) (Va "b")))) (Va "a"))
[((\x. (x ((\y. y) b))) a),(a ((\y. y) b)),(a b)]
*Main> l_normalitza_a (Ap (Ab "x" (Ap (Va "x") (Ap (Ab "y" (Va "y")) (Va "b")))) (Va "a"))
[((\x. (x ((\y. y) b))) a),((\x. (x b)) a),(a b)]
\end{lstlisting}

I finalment, amb les funcions normalitza (d'ordre superior), normalitza\_n, normalitza\_a, passa el mateix que amb l'anterior funció, les funcions normalitza\_n i normalitza\_a només fan la crida a la funció d'ordre superior (normalitza). La funció normalitza retorna una tupla amb el nombre de passos/$\beta$-reduccions fins a arribar a la forma normal menys 1 (l'últim element que és la forma normal), més la forma normal, llavors el nombre de passos és la llargada de la llista obtinguda amb l'anterior funció (l\_normalitza) menys 1, i la forma normal és l'últim element de la llista.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- normalitza, funcio d'ordre superior que evita la repeticio de codi entra la forma normal i l'aplicatiu
normalitza :: (LT -> [LT]) -> LT -> (Int, LT)
normalitza f t = (llargada (lpassos t) - 1,last (lpassos t))
    where lpassos = f

-- normalitza_n, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre normal
normalitza_n :: LT -> (Int, LT)
normalitza_n = normalitza (l_normalitza_n)

-- normalitza_a, rep un LT, i retorna una tupla amb el nombre de passos, mes el LT en forma normal, seguint l'ordre aplicatiu
normalitza_a :: LT -> (Int, LT)
normalitza_a = normalitza (l_normalitza_a)
\end{lstlisting}

Continuant amb els exemples anteriors.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
*Main> normalitza_n (Ap true (Va "a"))
(1,(\y. a))
*Main> normalitza_a (Ap true (Va "a"))
(1,(\y. a))
*Main> normalitza_n (Ap (Ab "x" (Ap (Va "x") (Ap (Ab "y" (Va "y")) (Va "b")))) (Va "a"))
(2,(a b))
*Main> normalitza_a (Ap (Ab "x" (Ap (Va "x") (Ap (Ab "y" (Va "y")) (Va "b")))) (Va "a"))
(2,(a b))
\end{lstlisting}

\clearpage

\subsection{Definicions del meta-llenguatge}

Com ja hem anat veient, hem implementat les definicions del meta-llenguatge vistes a teoria, i totes s'han implementat seguint el mateix esquema, i com que el tipus LT és instància de la classe Show, llavors es poden visualitzar igual que a teoria.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- identitat
iden :: LT
iden = Ab "x" (Va "x")
-- true
true :: LT
true = Ab "x" (Ab "y" (Va "x"))
-- false
false :: LT
false = Ab "x" (Ab "y" (Va "y"))
-- not
notDef :: LT
notDef = Ab "t" (Ap false true)
-- condicional
cond :: LT
cond = Ab "e" (Ab "e1" (Ab "e2" (Ap (Ap (Va "e") (Va "e1")) (Va "e2"))))

-- and, or i xor
andDef :: LT
andDef = Ab "x" (Ab "y" (Ap (Ap (Ap cond (Va "x")) (Va "y")) false))
orDef :: LT
orDef = Ab "x" (Ab "y" (Ap (Ap (Ap cond (Va "x")) true) (Va "y")))
xorDef :: LT
xorDef = Ab "x" (Ab "y" (Ap (Ap (Ap cond (Va "x")) (Ap notDef (Va "y"))) (Va "y")))

-- tupla, first i second
tupla :: LT
tupla = Ab "x" (Ab "y" (Ab "p" (Ap (Ap (Va "p") (Va "x")) (Va "y"))))
first :: LT
first = Ab "x" (Ap (Va "x") true)
second :: LT
second = Ab "x" (Ap (Va "x") false)

-- successor
succDef :: LT
succDef = Ab "n" (Ab "f" (Ab "x" (Ap (Ap (Va "n") (Va "f")) (Ap (Va "f") (Va "x")))))

-- predecessor
prefn :: LT
prefn = Ab "f" (Ab "p" (Ap (Ap tupla false) (Ap (Ap (Ap cond (Ap first (Va "p"))) (Ap second (Va "p"))) (Ap (Va "f") (Ap second (Va "p"))))))
prec :: LT
prec = Ab "n" (Ab "f" (Ab "x" (Ap second (Ap (Ap (Va "n") (Ap prefn (Va "f"))) (Ap (Ap tupla true) (Va "x"))))))

-- suma, producte i eszero
suma :: LT
suma = Ab "m" (Ab "n" (Ab "f" (Ab "x" (Ap (Ap (Va "m") (Va "f")) (Ap (Ap (Va "n") (Va "f")) (Va "x"))))))
producte :: LT
producte = Ab "m" (Ab "n" (Ab "f" (Ab "x" (Ap (Ap (Va "m") (Ap (Va "n") (Va "f"))) (Va "x")))))
eszero :: LT
eszero = Ab "n" (Ap (Ap (Va "n") (Ab "x" false)) true)
\end{lstlisting}

\clearpage

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- combinadors G i G'
g :: LT
g = Ab "x" (Ap (Ab "y" (Ab "x" (Ap (Va "y") (Va "y")))) (Ab "y" (Ab "x" (Ap (Va "y") (Va "y")))))
gprima :: LT
gprima = Ab "x" (Ap (Va "x") (Ap (Ab "y" (Ab "x" (Ap (Va "x") (Ap (Va "y") (Va "y"))))) (Ab "y" (Ab "x" (Ap (Va "x") (Ap (Va "y") (Va "y")))))))

-- combinadors de punt fixe
y :: LT
y = Ab "f" (Ap (Ab "x" (Ap (Va "f") (Ap (Va "x") (Va "x")))) (Ab "x" (Ap (Va "f") (Ap (Va "x") (Va "x")))))
t :: LT
t = Ap (Ab "x" (Ab "y" (Ap (Va "y") (Ap (Ap (Va "x") (Va "x")) (Va "y"))))) (Ab "x" (Ab "y" (Ap (Va "y") (Ap (Ap (Va "x") (Va "x")) (Va "y")))))
\end{lstlisting}

I també podem definir els naturals com.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
-- el zero
zero :: LT
zero = Ab "f" (Ab "x" (Va "x"))
-- els successors de zero son els numeros majors que 0
u :: LT
u = snd (normalitza_n (Ap succDef zero))
dos :: LT
dos = snd (normalitza_n (Ap succDef (Ap succDef zero)))
tres :: LT
tres = snd (normalitza_n (Ap succDef (Ap succDef (Ap succDef zero))))
quatre :: LT
quatre = snd (normalitza_n (Ap succDef tres))
cinc :: LT
cinc = snd (normalitza_n (Ap succDef quatre))
sis :: LT
sis = snd (normalitza_n (Ap succDef cinc))
set :: LT
set = snd (normalitza_n (Ap succDef sis))
vuit :: LT
vuit = snd (normalitza_n (Ap succDef set))
nou :: LT
nou = snd (normalitza_n (Ap succDef vuit))
deu :: LT
deu = snd (normalitza_n (Ap succDef nou))
\end{lstlisting}

Finalment, també podem definir el factorial com, una funció tal que esperi per paràmetre un combinador de punt fixe ($T$ o $Y$), i calculi i retorni el factorial.

\lstset{language=Haskell, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=mystyle]
factorial :: LT -> LT
factorial cf = Ap cf (Ab "f" (Ab "n" (Ap (Ap (Ap cond (Ap eszero (Va "n"))) u) (Ap (Ap producte (Va "n")) (Ap (Va "f") (Ap prec (Va "n")))))))
\end{lstlisting}

\clearpage

\subsection{Preguntes}

\textbf{Fins a quin factorial podeu calcular en 1 minut de temps?} \\

En un minut de temps podem fer fins al factorial de dos fent servir el combinador $T$.

\begin{lstlisting}[language=Haskell]
*Main> normalitza_n (Ap (factorial t) zero)
(12,(\f. (\x. (f x))))
*Main> normalitza_n (Ap (factorial t) u)
(59,(\f. (\x. (f x))))
*Main> normalitza_n (Ap (factorial t) dos)
(433,(\f. (\x. (f (f x)))))
\end{lstlisting}

I també fins al dos fent servir el combinador $Y$. Els dos fent servir l'ordre normal, ja que amb l'ordre aplicatiu entra en bucle o es penja.

\begin{lstlisting}[language=Haskell]
*Main> normalitza_n (Ap (factorial y) zero)
(12,(\f. (\x. (f x))))
*Main> normalitza_n (Ap (factorial y) u)
(58,(\f. (\x. (f x))))
*Main> normalitza_n (Ap (factorial y) dos)
(429,(\f. (\x. (f (f x)))))
\end{lstlisting}

\textbf{Podeu mirar de fer les funcions de $\beta$-reducció més eficients?} \\

Sí, en la funció redueix\_un\_n i redueix\_un\_a, en la definició del cas base, es pot canviar la crida a \textbf{conte\_redex} per \textbf{not (esta\_normal)}. I podem fer servir map, allà on apliquem una funció per cada element d'una llista. En tot cas, si quan executem el factorial es penja, no podem saber si està encara fent $\beta$-reduccions o si s'ha penjat. \textit{De totes maneres, el \href{https://imae.udg.edu/~villaret/tilc/TILC-Presentation.html}{Tilc} arriba fins al factorial de 3}. \\

\textbf{Se us acudeix alguna noció d’ordre entre LT per tal de poder fer el tipus LT instància d’Ord?} \\

Una possible noció d'ordre entre $\lambda$-termes és \textbf{la profunditat de l'arbre de parsing}, és a dir, \textbf{pel terme $\lambda_x x$ amb una profunditat de $1$}, comparat amb \textbf{el terme $\lambda_x x y$ amb una profunditat de 2}, això vol dir que \textbf{el primer és menor que el segon}, o dit d'una altra manera, el primer és menys profund que el segon. Per això hem implementat una nova funció auxiliar que s'encarrega de calcular la profunditat de l'arbre de parsing d'un terme qualsevol.

\begin{lstlisting}[language=Haskell]
-- get_depth, funcio que donat un LT, retorna la profunditat del seu arbre de parsing
get_depth :: LT -> Int
get_depth (Va a) = 0
get_depth (Ab _ t) = get_depth t + 1
get_depth (Ap t1 t2) = (get_depth t1 + get_depth t2) + 1
\end{lstlisting}

I ja podem fer que el \textbf{tipus LT sigui instància de la classe Ord}.

\begin{lstlisting}[language=Haskell]
instance Ord LT where
    compare t1 t2 | get_depth t1 == get_depth t2 = EQ
                  | get_depth t1 <= get_depth t2 = LT
                  | otherwise = GT
\end{lstlisting}

Provem amb l'exemple d'abans, és a dir, a veure si $(\lambda_x x) \leq (\lambda_x x y)$, i si comparem el primer amb el combinador $T$?

\begin{lstlisting}[language=Haskell]
*Main> (Ab "x" (Va "x")) <= (Ab "x" (Ap (Va "x") (Va "y")))
True
*Main> (Ab "x" (Va "x")) >= t
False
\end{lstlisting}

\clearpage

\section{Extra: Notació \textit{de Bruijn}}

\subsection{Tipus}

Per \textbf{la notació de Bruijn} hem definit un altre tipus de dades, que també és instància de les classes \textbf{Show} i \textbf{Eq}, igual que abans, l'únic que canvia en aquest tipus, és que ja no tenim variables en les $\lambda$-abstraccions, i les variables que abans eren cadenes de text, ara són enters, més concretament és la distància de cada variable en lambdes.

\begin{lstlisting}[language=Haskell]
data LTdB = VadB Int | ApdB LTdB LTdB | AbdB LTdB

-- que tambe sera instancia de la classe Show i Eq
instance Show LTdB where
    show (VadB a) = show a
    show (ApdB t1 t2) = "(" ++ show t1 ++ " " ++ show t2 ++ ")"
    show (AbdB t1) = "(\\" ++ ". " ++ show t1 ++ ")"

-- definim la mateixa idea d'equivalencia que teniem en els lambda termes pels lambda termes amb notacio de Bruijn
instance Eq LTdB where
    (==) (VadB a) (VadB b) = a == b
    (==) (ApdB t1 t2) (ApdB t1' t2') = (&&) (t1 == t1') (t2 == t2')
    (==) (AbdB t1) (AbdB t2) = t1 == t2
    (==) _ _ = False
\end{lstlisting}

També hem hagut de definir un \textbf{Context} per convertir un $\lambda$-terme clàssic a notació de Bruijn, i l'hem definit com.

\begin{lstlisting}[language=Haskell]
type Context = [(String,Int)]
\end{lstlisting}

L'explicació de per què un \textbf{Context} és una llista de tuples de cadenes de caràcters i enters, és que d'aquesta manera cada $\lambda$-terme tindrà una llista amb una tupla per cada variable, on hi haurà la relació entre el nom de la variable (primera posició de la tupla) amb la posició o distància en lambdes (segona posició de la tupla), de forma semblant a un map que mapeji noms de variables cap a enters.

\clearpage

\subsection{Funcions auxiliars}

Per implementar aquest extra, ha sigut necessària la implementació de les següents funcions, que ns permeten a partir d'un $\lambda$-terme, i de la tupla amb les variables lliures i lligades, definir un Context com una llista de tuples, \textit{semblant a un map}, que mapeja noms de variables cap a enters. I el funcionament és, com que freeAndboundVars retorna les variables ordenades per ordre d'aparició, és a dir, la primera variable apareix a la primera posició, i successivament, llavors a cada variable lligada li podem assignar un número correlatiu de $0$ a $n-1$, i finalment concatenar a la llista les variables lliures, i fer el mateix, però des de $n$ fins que s'acabin les variables lliures.

\begin{lstlisting}[language=Haskell]
-- get_cont_aux, funcio que per cada variable d'una llista li assigna un numero correlatiu de 0 a n
get_cont_aux :: Int -> [String] -> Context
get_cont_aux _ [] = []
get_cont_aux n (x:xs) = (x,n):get_cont_aux (n+1) xs

-- get_cont, funcio que donat un LT, retorna el seu Context
get_cont :: LT -> Context
get_cont t = get_cont_aux 0 ls ++ get_cont_aux ((llargada ls) + 1) lf
    where lf = fst (freeAndboundVars t)
          ls = snd (freeAndboundVars t)
\end{lstlisting}

Exemples.

\begin{lstlisting}[language=Haskell]
*Main> get_cont suma
[("m",0),("n",1),("f",2),("x",3)]
*Main> get_cont t
[("x",0),("y",1)]
*Main> get_cont cond
[("e",0),("e1",1),("e2",2)]
\end{lstlisting}

La següent funció ho diu el nom, mapeja elements dins d'una llista (element first), i retorna el seu corresponent valor (second).

\begin{lstlisting}[language=Haskell]
-- mapeja_str_to_int, funcio que mapeja una cadena de text (variable) cap a un enter (posicio o distancia en lambdes)
mapeja :: Eq a => a -> [(a,b)] -> b
mapeja a (t:ts) = if a == fst t then snd t else mapeja a ts
\end{lstlisting}

Exemples.

\begin{lstlisting}[language=Haskell]
*Main> mapeja "e" (get_cont cond)
0
*Main> get_cont cond
[("e",0),("e1",1),("e2",2)]
*Main> mapeja "e" (get_cont cond)
0
\end{lstlisting}

\clearpage

\subsection{Funcions principals}

Un cop implementades les funcions auxiliars, implementar la següent funció és senzill, només és una traducció de variables a enters, i acabar construint un $\lambda$-terme amb notació de Bruijn.

\begin{lstlisting}[language=Haskell]
-- a_deBruijn, funcio que rep un LT i un Context, i el passa a LTdB
a_deBruijn :: LT -> Context -> LTdB
a_deBruijn (Va a) c = VadB (mapeja (head (filter (==a) (map fst c))) c)
a_deBruijn (Ap t1 t2) c = ApdB (a_deBruijn t1 c) (a_deBruijn t2 c)
a_deBruijn (Ab _ t) c = AbdB (a_deBruijn t c)
\end{lstlisting}

Exemples.

\begin{lstlisting}[language=Haskell]
*Main> suma
(\m. (\n. (\f. (\x. ((m f) ((n f) x))))))
*Main> a_deBruijn suma (get_cont suma)
(\. (\. (\. (\. ((0 2) ((1 2) 3))))))
*Main> t
((\x. (\y. (y ((x x) y)))) (\x. (\y. (y ((x x) y)))))
*Main> a_deBruijn t (get_cont t)
((\. (\. (1 ((0 0) 1)))) (\. (\. (1 ((0 0) 1)))))
*Main> cond
(\e. (\e1. (\e2. ((e e1) e2))))
*Main> a_deBruijn cond (get_cont cond)
(\. (\. (\. ((0 1) 2))))
\end{lstlisting}

La següent funció ja no és tant senzilla.

\begin{lstlisting}[language=Haskell]
-- de_deBruijn, funcio que rep un LTdB i el passa a LT
de_deBruijn :: LTdB -> LT
\end{lstlisting}

\end{document}
